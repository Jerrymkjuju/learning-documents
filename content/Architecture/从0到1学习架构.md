[TOC]



## 01 架构是什么

需要关注几个概念

- *系统-子系统*：“系统泛指由一群有**关联**的个体组成，根据某种**规则**运作，**能完成个别元件不能单独完成的工作的群体**（提供新的能力）。它的意思是“总体”“整体”或“联盟”

- *模块和组件*：“从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。**划分模块的主要目的是职责分离；划分组件的主要目的是单元复用**。”

  > “组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。”

- *框架和架构*：

  **架构：“软件架构指软件系统的顶层结构”**

  - “软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件**组件规范**，也指为了实现某个软件组件规范时，**提供规范所要求之基础功能的软件产品**”

    > 1. “框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。”
    >
    > 2. “框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能”

  - “软件架构指软件系统的**“基础结构”**，创造这些基础结构的准则，以及对这些结构的描述。”

  - “框架关注的是“规范”，架构关注的是“结构” ，框架的英文是 Framework，架构的英文是 Architecture”

  - 但是很多时候会模棱两可，因为“基础结构”这个概念并没有明确说是从什么角度来分解的。采用不同的角度或者维度，可以将系统划分为不同的结构” - 业务、技术角度等等

    > <u>*TODO：学习了解 “ IBM 的 RUP 将软件架构视图分为著名的 4+1 视图的原因。”*</u>

## 02 软件架构的历史背景

机器语言 -> 汇编语言 -> 高级语言 -> 结构化程序设计（第一次软件危机） -> 面向对象（第二次软件危机）

> 第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂。



## 03 架构设计的目的

***“为了解决软件系统复杂度带来的问题 。”***



## 04 复杂度来源：高性能

技术的发展会带来性能的提升，但并不一定带来负责度的提升，只有那些并不是用来取代旧技术，而是开辟了一个全新领域的技术，才会给软件系统带来复杂度。

软件系统中高性能带来的复杂度主要体现在两方面：

- 一方面是**单台计算机内部**为了高性能带来的复杂度
- 另一方面是**多台计算机集群**为了高性能带来的复杂度 

### 单机复杂度

“计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展”。

进程 -> 线程 -> 多核：“有了多线程后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。”

> “这些技术并不是最新的就是最好的，也不是非此即彼的选择，在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合”
>
> 如：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大
>

### 集群复杂度

> *随着业务的发展，单机的性能是很难支撑复杂业务的，必须采用机器集群的方式来达到高性能*

- **任务分配**（不断加机器)

  - 每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行

  - 复杂度提升的点

    - 需要增加一个任务分配器（硬件网络设备：F5、交换机；软件网络设备：LVS；负载均衡软件：Nginx，HAProxy；某种分配算法：memcache）

      > 实际上“任务”涵盖的范围很广，可以指完整的业务处理，也可以单指某个具体的任务 。例如，“存储”“运算”“缓存”等都可以作为一项任务，因此存储系统、运算系统、缓存系统都可以按照任务分配的方式来搭建架构。此外，“任务分配器”也并不一定只能是物理上存在的机器或者一个独立运行的程序，也可以是嵌入在其他程序中的算法，例如 Memcache 的集群架构。（分配算法嵌套在客户端程序中）
      >
      > 
      >
      > 
      >
      > <img src="从0到1学习架构.assets/image-20230414083122914.png" alt="image-20230414083122914" style="zoom:30%;" />
      >
      > 
      >
      > <u>*TODO：学习了解 Memcache 架构*</u>

      

    - 任务分配器和业务服务器之间的连接管理

    - 任务的分配算法（轮询、权重、负载等等）

    - 任务分配器的扩容（任务分配器也需要分配；*一对多关系变为多对多关系*；机器数量增加导致故障处理时会更复杂）

- **任务分解**
  - 业务越来越复杂，单台机器处理的性能会越来越低
  - 本质上就是微服务，根据业务进行服务拆分
    - 简单的系统更加容易做的高性能
    - 可以针对单个任务进行扩展

## 05 复杂度来源：高可用

> *系统**无中断地执行其功能**的能力，代表系统的可用性程度，是进行系统设计时的准则之一。*
>
> *系统的高可用方案五花八门，但万变不离其宗，**本质上都是通过 “冗余” 来实现高可用***
>
> ------
>
> ***高性能增加机器目的在于“扩展”处理性能；***
>
> ***高可用增加机器目的在于“冗余”处理单元***

### 计算高可用

- 无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的

- 分配器和高性能类似，常见的双机算法有**主备、主主**，主备方案又可以细分为冷备、温备、热备（区别在于是否可以随时提供服务）

  > ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备
  >

### 存储高可用

> 1. *存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输*
>
> 2. 除了物理上的传输速度限制，传输线路本身也存在可用性问题，传输线路可能中断、可能拥塞、可能异常（错包、丢包），并且传输线路的故障时间一般都特别长，短的十几分钟，长的几个小时都是可能的

- 存储高可用的难点不在于如何备份数据，而**在于如何减少或者规避数据不一致对业务造成的影响**。

### 状态决策

> 通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确

| 决策方式 | 方式                                                         | 难点或者缺陷                                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 独裁式   | 独立的决策主体，所有冗余的个体都上报状态信息给决策者         | 决策者本身故障时，无法做出正确的决策                         |
| 协商式   | 两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策 | 如果两者的信息交换出现问题（比如主备连接中断）时如何处理     |
| 民主式   | 多个独立的个体通过投票的方式来进行状态决策（ZooKeeper的leader选举，选举算法Paxos）<br />*TODO ZK Paxos选举算法* | 算法复杂<br />可能会脑裂<br />- 为了解决脑裂问题，民主式决策的系统一般都采用“投票节点数必须超过系统总节点数一半”规则来处理 |

## 06 复杂度来源：可扩展

两个基本条件

1. 正确预测变化

   > 复杂度来源：*不能每个设计点都考虑可扩展性。不能完全不考虑可扩展性。所有的预测都存在出错的可能性*

2. 完美封装变化

   1. 将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层
   2. 提炼出一个“抽象层”和一个“实现层“（设计模式、规则引擎）